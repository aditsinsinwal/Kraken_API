# -*- coding: utf-8 -*-
"""Untitled20.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Le0gOfitKynl_-qMhhIDz3QUnT_JI8uV
"""

#importing required libraries
import requests
import json

def get_ethereum_data():
    # Define the endpoint URL for the Ticker information
    url = "https://api.kraken.com/0/public/Ticker"

    # Define the parameters for the request
    params = {
        'pair': 'XETHZCAD'  # This is the trading pair for Ethereum to USD
    }

    # Make the GET request to Kraken's API
    response = requests.get(url, params=params)

    # Check if the request was successful
    if response.status_code == 200:
        # Parse the JSON response
        data = response.json()

        # Extract the relevant information
        eth_data = data['result']['XETHZCAD']

        # Print the extracted data
        print(json.dumps(eth_data, indent=4))
    else:
        print(f"Error: Unable to fetch data (status code: {response.status_code})")

# Call the function to get Ethereum data
get_ethereum_data()

import requests
import time
import csv

def get_ohlc_data(pair, interval=1, limit=730):
    url = "https://api.kraken.com/0/public/OHLC"
    since = 0
    all_data = []

    while len(all_data) < limit:
        params = {
            'pair': pair,
            'interval': interval,
            'since': since
        }

        try:
            response = requests.get(url, params=params)
            response.raise_for_status()
        except requests.exceptions.HTTPError as errh:
            print(f"Http Error: {errh}")
            break
        except requests.exceptions.ConnectionError as errc:
            print(f"Error Connecting: {errc}")
            break
        except requests.exceptions.Timeout as errt:
            print(f"Timeout Error: {errt}")
            break
        except requests.exceptions.RequestException as err:
            print(f"OOps: Something Else {err}")
            break

        data = response.json()

        if data['error']:
            print(f"Error: {data['error']}")
            break

        result = data['result']
        ohlc_data = result[pair]

        if not ohlc_data:
            print("No more data to fetch.")
            break

        all_data.extend(ohlc_data)

        # Update 'since' to the last timestamp + 1
        since = ohlc_data[-1][0] + 1

        # Stop if the limit is reached
        if len(all_data) >= limit:
            all_data = all_data[:limit]  # Trim to the exact limit if overfetched
            break

        print(f"Fetched {len(ohlc_data)} records. Total records so far: {len(all_data)}. Sleeping for 2 seconds...")
        time.sleep(2)  # Increase sleep duration to avoid rate limits

    return all_data

def save_to_csv(data, filename):
    header = ['time', 'open', 'high', 'low', 'close', 'vwap', 'volume', 'count']
    with open(filename, mode='w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(header)
        writer.writerows(data)

if __name__ == "__main__":
    pair = 'XETHZUSD'
    interval = 60  # 1-hour intervals
    limit = 730  # Set the desired limit of records to fetch
    data = get_ohlc_data(pair, interval, limit)
    save_to_csv(data, 'eth_usd_ohlc_data.csv')
    print(f"Saved {len(data)} rows of data to 'eth_usd_ohlc_data.csv'")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Load data from CSV
data = pd.read_csv('eth_usd_ohlc_data.csv')

# Convert timestamp to datetime
data['time'] = pd.to_datetime(data['time'], unit='s')

# Set the time column as the index
data.set_index('time', inplace=True)

# Calculate moving averages
data['SMA_20'] = data['close'].rolling(window=20).mean()
data['SMA_50'] = data['close'].rolling(window=50).mean()

# Trading signals
data['Signal'] = 0
data['Signal'][20:] = np.where(data['SMA_20'][20:] > data['SMA_50'][20:], 1, 0)  # Buy signal
data['Position'] = data['Signal'].diff()  # Buy=1, Sell=-1

# Plot the data
plt.figure(figsize=(14, 7))
plt.plot(data['close'], label='ETH/USD Close Price', alpha=0.5)
plt.plot(data['SMA_20'], label='20-period SMA', alpha=0.75)
plt.plot(data['SMA_50'], label='50-period SMA', alpha=0.75)
plt.plot(data[data['Position'] == 1].index, data['SMA_20'][data['Position'] == 1], '^', markersize=10, color='g', lw=0, label='Buy Signal')
plt.plot(data[data['Position'] == -1].index, data['SMA_20'][data['Position'] == -1], 'v', markersize=10, color='r', lw=0, label='Sell Signal')
plt.title('ETH/USD Price and Trading Signals')
plt.legend(loc='best')
plt.show()

# Print the data with signals
print(data.tail())

# Load data from CSV
data = pd.read_csv('eth_usd_ohlc_data.csv')

# Convert timestamp to datetime
data['time'] = pd.to_datetime(data['time'], unit='s')

# Set the time column as the index
data.set_index('time', inplace=True)

# Resample data to 4-hour intervals
data_4h = data.resample('4H').agg({
    'open': 'first',
    'high': 'max',
    'low': 'min',
    'close': 'last',
    'vwap': 'mean',
    'volume': 'sum',
    'count': 'sum'
})

# Drop rows with NaN values that result from resampling
data_4h.dropna(inplace=True)

# Calculate the RSI
def calculate_rsi(data, window=14):
    delta = data['close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

data_4h['RSI'] = calculate_rsi(data_4h, window=14)

# Calculate moving averages
data_4h['SMA_20'] = data_4h['close'].rolling(window=20).mean()
data_4h['SMA_50'] = data_4h['close'].rolling(window=50).mean()

# Trading signals based on RSI
data_4h['RSI_Signal'] = 0
data_4h['RSI_Signal'][data_4h['RSI'] < 30] = 1  # Buy signal
data_4h['RSI_Signal'][data_4h['RSI'] > 70] = -1  # Sell signal

# Trading signals based on moving average crossover
data_4h['SMA_Signal'] = 0
data_4h['SMA_Signal'][20:] = np.where(data_4h['SMA_20'][20:] > data_4h['SMA_50'][20:], 1, 0)  # Buy signal
data_4h['SMA_Signal'][20:] = np.where(data_4h['SMA_20'][20:] < data_4h['SMA_50'][20:], -1, data_4h['SMA_Signal'][20:])  # Sell signal

# Combine signals
data_4h['Signal'] = data_4h['RSI_Signal'] + data_4h['SMA_Signal']

# Determine action
if data_4h['Signal'].iloc[-1] > 0:
    decision = "Buy"
elif data_4h['Signal'].iloc[-1] < 0:
    decision = "Sell"
else:
    decision = "Hold"

print(f"Decision based on the past 4-hour data: {decision}")